# Broken RSA
## Description
> I tried to send you an important message with RSA, however I messed up my RSA implementation really badly. Can you still recover the flag?\
> Hint: If you think you're doing the right thing but getting garbage, be sure to check all possible solutions.
## My solution
After trying online number factorizer to factorize `n`, I realized that `n` is a prime instead of semi-prime like most RSA moduli. 
So $\phi{n} = n-1 \$. At first, I naturally tried to find `d` that satisfies $\ d = e^{-1} mod (n-1) \$. However it didn't work because $\gcd(e,n-1)\ \neq\ 1$.\
\
The hint gave us another idea. I tried to solve `m` such that $\ (((m^2)^2)^2)^2\ \equiv\ \ m^{16}\ \equiv\ \ ct\ mod n\$. This can be done by taking square root 4 times (of course by the end there could be up to 16 solutions to consider).
Because `n` is a prime and $n \equiv\$ $1$ $mod 4\$ so I used Tonelli-Shanks algorithm.
```
n = 27772857409875257529415990911214211975844307184430241451899407838750503024323367895540981606586709985980003435082116995888017731426634845808624796292507989171497629109450825818587383112280639037484593490692935998202437639626747133650990603333094513531505209954273004473567193235535061942991750932725808679249964667090723480397916715320876867803719301313440005075056481203859010490836599717523664197112053206745235908610484907715210436413015546671034478367679465233737115549451849810421017181842615880836253875862101545582922437858358265964489786463923280312860843031914516061327752183283528015684588796400861331354873
e = 16
ct = 11303174761894431146735697569489134747234975144162172162401674567273034831391936916397234068346115459134602443963604063679379285919302225719050193590179240191429612072131629779948379821039610415099784351073443218911356328815458050694493726951231241096695626477586428880220528001269746547018741237131741255022371957489462380305100634600499204435763201371188769446054925748151987175656677342779043435047048130599123081581036362712208692748034620245590448762406543804069935873123161582756799517226666835316588896306926659321054276507714414876684738121421124177324568084533020088172040422767194971217814466953837590498718
def recur(e,res,mod):
  if(e==1):
    kk=long_to_bytes(res)
    print(kk)
    print()
    return
  sq=tonelli_shanks(res,mod)
  for i in sq:
    recur(e//2,i,mod)
recur(e,ct,n)
```
I found all the solutions possible by using recursion, change each one to bytes by `long_to_bytes` and only one makes sense:
```
b"Hey, if you are reading this maybe I didn't mess up my code too much. Phew. I really should play more CryptoHack before rushing to code stuff from scratch again. Here's the flag: crypto{m0dul4r_squ4r3_r00t}"
```
