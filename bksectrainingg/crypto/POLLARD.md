## Description
[chal.py](https://training.bksec.vn/apiv2/files/local/htyVyRWyNOXosQCLiYZby?iat=1771486800&sig=VIB1z5GY7sbSDKiMvwu2UNkzDfXU_CDlHr3fb6GAfzs)\
[output.txt](https://training.bksec.vn/apiv2/files/local/zugu--DQou16jpZmR6gKs?iat=1771486800&sig=n47cT7ryS-j3md04bfswCluH29qEXC_66lFW-seEybE)
## My solution
The problem's name is **POLLARD**, which may refer to factorizing $N$ knowing $p-1$. However, as this problem gives a multiple of $(p+1)$, we should
use William's p+1 algorithm, which has similar idea. Let the Lucas sequence be:
$V_0=2, V_1=a$ and $V_i=a.V_{i-1}-V_{i-2}$. A nice property of this sequence: if $K$ is a multiple of $p+1$, $V_K \equiv 2 \pmod{p}$.\
The proof is complicated so I will not go into details here. So we can get a multiple of $p$ by calculating a Lucas number, subtract 2. Take `gcd` of N and that result, we may end up finding $p$.
```
def lucas(P, k, p):
    K = IntegerModRing(p)
    M = matrix(K, [[P, -1], [1, 0]])
    V = vector(K, [P, 2])
    res = (M**(int(k)-1)) * V
    return res[0]

c = 82492338462867184535544519876467181897706433879816937454372001444130157837864109082120600939704535688028487264029927145808480175073551946152918847231803296533045308111160301980991377209224049251522497536193211572832961294066482086749159892667851055664700783523254872397914882670234537615168814788639494701701
n = 90732283493301175709195758420997909994530988132180860604603158584056525479947267813294117215773182064539338342622761436159447894240577239175191709657472786588844715041498464180512007984418147941276105745077318786952158423292680637562167348553335086556096816144842567829861754885625261732391712295056877882121
hint = 94669411641141163082336260387181611400441357024917532200885783434982674643240190944427103877466077819763538826903786257975686089601056263908452108810942741938289978436468325996173206832947380490977405198760825961668710324450010032662560091998986503908206247636907416743458237953375238189949467344490812471266
e = 65537

kk = lucas(3, hint, n)
p = gcd(int(kk) - 2, n)
q = n // p
phi = (p - 1) * (q - 1)
d = inverse_mod(e, phi)
m = pow(int(c), int(d), int(n))
print(long_to_bytes(m))
```
```
b'BKSEC{34fb3cd74f4ada52c9ce5b7e66b9fe01fa114577b01c0c29ed3ece91bd3f8156}'
```
